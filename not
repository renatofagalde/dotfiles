package main

import (
	"fmt"
	"syscall"
	"time"
	"unsafe"
)

var (
	user32           = syscall.NewLazyDLL("user32.dll")
	getLastInputInfo = user32.NewProc("GetLastInputInfo")
	keybdEvent       = user32.NewProc("keybd_event")
)

type LASTINPUTINFO struct {
	cbSize uint32
	dwTime uint32
}

const (
	VK_MENU        = 0x12 // Alt key
	VK_TAB         = 0x09 // Tab key
	KEYEVENTF_KEYUP = 0x02
)

func getIdleTime() (time.Duration, error) {
	var lii LASTINPUTINFO
	lii.cbSize = uint32(unsafe.Sizeof(lii))
	r, _, err := getLastInputInfo.Call(uintptr(unsafe.Pointer(&lii)))
	if r == 0 {
		return 0, err
	}

	// Pega o tempo atual do sistema e subtrai do último evento
	tickCount := uint32(time.Now().UnixMilli())
	idleMillis := tickCount - lii.dwTime

	return time.Duration(idleMillis) * time.Millisecond, nil
}

func simulateAltTab() {
	// Pressiona Alt
	keybdEvent.Call(VK_MENU, 0, 0, 0)
	time.Sleep(50 * time.Millisecond)

	// Pressiona Tab
	keybdEvent.Call(VK_TAB, 0, 0, 0)
	time.Sleep(50 * time.Millisecond)

	// Solta Tab
	keybdEvent.Call(VK_TAB, 0, KEYEVENTF_KEYUP, 0)
	time.Sleep(50 * time.Millisecond)

	// Solta Alt
	keybdEvent.Call(VK_MENU, 0, KEYEVENTF_KEYUP, 0)
}

func main() {
	fmt.Println("Monitorando inatividade...")
	lastAction := time.Now() // Marca o tempo da última ação (inicialmente agora)

	for {
		idleDuration, err := getIdleTime()
		if err != nil {
			fmt.Printf("[%s] Erro ao obter tempo de inatividade: %v\n", time.Now().Format("15:04:05"), err)
			continue
		}

		// Log de inatividade detectada com hora atual
		fmt.Printf("[%s] Tempo de inatividade: %v\n", time.Now().Format("15:04:05"), idleDuration)

		// Executa Alt+Tab a cada 4 minutos de inatividade
		if idleDuration >= 4*time.Minute && time.Since(lastAction) >= 4*time.Minute {
			fmt.Printf("[%s] Inatividade detectada! Simulando Alt+Tab.\n", time.Now().Format("15:04:05"))
			simulateAltTab()
			lastAction = time.Now() // Atualiza o tempo da última ação do Alt+Tab
		}

		time.Sleep(5 * time.Second) // Verifica a cada 5 segundos
	}
}
