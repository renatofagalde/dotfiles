package main

import (
	"fmt"
	"syscall"
	"time"
	"unsafe"
)

var (
	user32           = syscall.NewLazyDLL("user32.dll")
	getLastInputInfo = user32.NewProc("GetLastInputInfo")
	keybdEvent       = user32.NewProc("keybd_event")
)

type LASTINPUTINFO struct {
	cbSize uint32
	dwTime uint32
}

const (
	VK_MENU       = 0x12 // Alt key
	VK_TAB        = 0x09 // Tab key
	KEYEVENTF_KEYUP = 0x02
)

func getIdleTime() (uint32, error) {
	var lii LASTINPUTINFO
	lii.cbSize = uint32(unsafe.Sizeof(lii))
	r, _, err := getLastInputInfo.Call(uintptr(unsafe.Pointer(&lii)))
	if r == 0 {
		return 0, err
	}
	tickCount := uint32(time.Now().UnixMilli())
	return tickCount - lii.dwTime, nil
}

func simulateAltTab() {
	// Pressiona Alt
	keybdEvent.Call(VK_MENU, 0, 0, 0)
	time.Sleep(50 * time.Millisecond)

	// Pressiona Tab
	keybdEvent.Call(VK_TAB, 0, 0, 0)
	time.Sleep(50 * time.Millisecond)

	// Solta Tab
	keybdEvent.Call(VK_TAB, 0, KEYEVENTF_KEYUP, 0)
	time.Sleep(50 * time.Millisecond)

	// Solta Alt
	keybdEvent.Call(VK_MENU, 0, KEYEVENTF_KEYUP, 0)
}

func main() {
	fmt.Println("Monitorando inatividade...")

	for {
		idleTime, err := getIdleTime()
		if err != nil {
			fmt.Println("Erro ao obter tempo de inatividade:", err)
			continue
		}

		if idleTime > 240000 { // 4 minutos em milissegundos
			fmt.Println("Inatividade detectada! Simulando Alt+Tab.")
			simulateAltTab()
		}

		time.Sleep(5 * time.Second) // Verifica a cada 5 segundos
	}
}
